# 냅색 알고리즘 (동전 교환 알고리즘)

#### DP 알고리즘

먼저 동전 거스름돈 액수 만큼의 배열 크기를 가진 배열을 준비한다. 

       1    2    3    4    5    6    7    8    9

1     0    0    0    0    0    0    0    0   0

3     0    0    0    0    0    0    0    0   0                          

4     0    0    0    0    0    0    0    0   0    

1원 짜리 동전을 이용하여 1원 부터 9원까지 필요한 경우의 수를 각각 채워 넣는다. 1원을 만들기 위해 1원짜리 1개, 2원을 만들기 위해 1원짜리 2개가 필요하며, 9원을 만들기 위해서는 9원이 필요하다.

1    2    3    4    5    6    7    8    9

1      1    2    3    4    5    6    7    8    9

3     0    0    0    0    0    0    0    0   0                          

4     0    0    0    0    0    0    0    0   0    

3원 짜리 동전을 이용하여 같은 방법으로 채워 넣는다. 3원 짜리 동전을 만들기 위해 3원짜리 1개, 4원은 3원짜리 1개, 1원짜리 1개가 필요하다.

1    2    3    4    5    6    7    8    9

1      1    2    3    4    5    6    7    8    9

3     1    2    1    2    3    2    3    4    3                            

4     0    0    0    0    0    0    0   0    0    

4원도 같은 방법으로 채워 넣으면 최종은 다음과 같다.

1    2    3    4    5    6    7    8    9

1     1    2    3    4    5    6    7    8    9

3    1    2    1    2    3    2    3    4    3                          

4    1    2    1    1    2    2    3     2    3                

여기서 코드 구현을 위해 4원짜리가 채워지는 방법을 조금 깊게 들여다 보자. 세로열의 값들은 거스름 돈을 구성하기 위한 동전의 갯수를 의미한다. 즉, 1원 짜리는 1개, 2원짜리는 2개, 3원짜리는 1개가 필요하다는 것을 의미한다.

5원 : 4원 + 1원,     6원 : 4원 + 1원 + 1원,      7원 : 4원 + 3원이 필요한데, 5-4를 빼면 1원을 만들기 위한 갯수가 나오고, 6-4를 하면 2원을 만들기 위한 갯수가 나온다. 이를 코드로 표현하면 다음과 같다.

```
// 먼저 check 배열을 Integer.MAX_VALUE로 초기화한다. 

check = new int[m + 1];
for(int i = 1; i <= m; i++) {
	check[i] = Integer.MAX_VALUE;
}

for(int coin : coins) {
        check[coin] = 1;
        for(int idx = coin; idx <= m; idx++) {
        check[idx] = Math.min(check[idx], check[idx-coin] + 1);
}
```

#### 관련문제
[동전 교환](/src/dy/inflearn/Ch10_5.java)
[최대 점수 구하기](/src/dy/inflearn/Ch10_6.java)